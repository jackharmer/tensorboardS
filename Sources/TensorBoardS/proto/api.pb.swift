// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 The TensorFlow Authors. All Rights Reserved.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//==============================================================================

// Defines a proto3-based REST API that the HParams web-component of the plugin
// would use to read data from a hyperparameter-tuning experiment.
// This file defines the message types (resources) used
// to pass information into and out of the API methods. These messages will be
// transmitted using proto3 native JSON encoding. See http_api.md for a
// description of the actual HTTP API.

// General note: in what follows we use the field 'name' of a message to
// stores its id. We avoid calling this field 'id' since it is a reserved word
// in Python, as well as to be more compliant with the API style guide
// detailed in https://cloud.google.com/apis/design/.

// IMPORTANT: If you change any of the messages here, make sure to also update
// api.d.ts accordingly.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum TensorBoardS_Hparam_DataType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unset // = 0
  case string // = 1
  case bool // = 2
  case float64 // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unset
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unset
    case 1: self = .string
    case 2: self = .bool
    case 3: self = .float64
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unset: return 0
    case .string: return 1
    case .bool: return 2
    case .float64: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TensorBoardS_Hparam_DataType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [TensorBoardS_Hparam_DataType] = [
    .unset,
    .string,
    .bool,
    .float64,
  ]
}

#endif  // swift(>=4.2)

enum TensorBoardS_Hparam_DatasetType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case datasetUnknown // = 0
  case datasetTraining // = 1
  case datasetValidation // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .datasetUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .datasetUnknown
    case 1: self = .datasetTraining
    case 2: self = .datasetValidation
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .datasetUnknown: return 0
    case .datasetTraining: return 1
    case .datasetValidation: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TensorBoardS_Hparam_DatasetType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [TensorBoardS_Hparam_DatasetType] = [
    .datasetUnknown,
    .datasetTraining,
    .datasetValidation,
  ]
}

#endif  // swift(>=4.2)

/// Represents the status of a Session.
enum TensorBoardS_Hparam_Status: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case success // = 1
  case failure // = 2
  case running // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .success
    case 2: self = .failure
    case 3: self = .running
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .success: return 1
    case .failure: return 2
    case .running: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TensorBoardS_Hparam_Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [TensorBoardS_Hparam_Status] = [
    .unknown,
    .success,
    .failure,
    .running,
  ]
}

#endif  // swift(>=4.2)

enum TensorBoardS_Hparam_SortOrder: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case orderUnspecified // = 0
  case orderAsc // = 1
  case orderDesc // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .orderUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .orderUnspecified
    case 1: self = .orderAsc
    case 2: self = .orderDesc
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .orderUnspecified: return 0
    case .orderAsc: return 1
    case .orderDesc: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TensorBoardS_Hparam_SortOrder: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [TensorBoardS_Hparam_SortOrder] = [
    .orderUnspecified,
    .orderAsc,
    .orderDesc,
  ]
}

#endif  // swift(>=4.2)

enum TensorBoardS_Hparam_AggregationType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case aggregationUnset // = 0
  case aggregationAvg // = 1
  case aggregationMedian // = 2
  case aggregationMin // = 3
  case aggregationMax // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .aggregationUnset
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .aggregationUnset
    case 1: self = .aggregationAvg
    case 2: self = .aggregationMedian
    case 3: self = .aggregationMin
    case 4: self = .aggregationMax
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .aggregationUnset: return 0
    case .aggregationAvg: return 1
    case .aggregationMedian: return 2
    case .aggregationMin: return 3
    case .aggregationMax: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TensorBoardS_Hparam_AggregationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [TensorBoardS_Hparam_AggregationType] = [
    .aggregationUnset,
    .aggregationAvg,
    .aggregationMedian,
    .aggregationMin,
    .aggregationMax,
  ]
}

#endif  // swift(>=4.2)

/// Represents a single experiment.
/// An experiment consists of multiple "sessions". Typically, in each session
/// a model is trained for a given set of hyperparameter values. In each session
/// a training program may generate one or more series of real numbers--each
/// containing the evaluation of some metric on the model at different training
/// steps.
///
/// Note that Sessions can consist of multiple Tensorboard "runs", since in
/// a distributed Tensorflow deployment, training can be accomplished using
/// several cooporating processes, each one emitting Summary data to a different
/// log directory or run. For example, in a single session one process could
/// periodically compute the loss on the validation set, and another could
/// compute the loss on the training set.
/// NEXT_TAG: 7
struct TensorBoardS_Hparam_Experiment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// -- Experiments are scoped by a global name.
  /// Currently, Tensorboard supports displaying data for a single experiment.
  var name: String = String()

  /// A description. May contain markdown.
  var description_p: String = String()

  /// An id for the owning user or group.
  var user: String = String()

  /// The time the experiment was created. In seconds since the UNIX epoch.
  var timeCreatedSecs: Double = 0

  /// Information about each hyperparameter used in the experiment.
  var hparamInfos: [TensorBoardS_Hparam_HParamInfo] = []

  /// Information about each metric used in the experiment.
  var metricInfos: [TensorBoardS_Hparam_MetricInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// NEXT_TAG: 7
struct TensorBoardS_Hparam_HParamInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An id for the hyperparameter.
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// A string used to display the hyperparameter in the UI. If empty, the UI
  /// will display the 'name' field.
  var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  /// A description. May contain markdown.
  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// The data type of this hyperparameter.
  var type: TensorBoardS_Hparam_DataType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// Specifies the set of values this hyperparameter can hold. The UI assumes
  /// every instance of this hyperparameter will hold a value from this set. It
  /// is used by the UI to allow filtering so that only session groups (see
  /// below) whose associated hyperparameter value "passes" the filter are
  /// displayed. If this is not populated, the domain is assumed to be the
  /// entire domain of the type of the hyperparameter.
  var domain: OneOf_Domain? {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  /// A discrete set of the values this hyperparameter can hold.
  var domainDiscrete: SwiftProtobuf.Google_Protobuf_ListValue {
    get {
      if case .domainDiscrete(let v)? = _storage._domain {return v}
      return SwiftProtobuf.Google_Protobuf_ListValue()
    }
    set {_uniqueStorage()._domain = .domainDiscrete(newValue)}
  }

  /// Numeric data type only. The (real) interval from which values of this
  /// hyperparameter are taken.
  var domainInterval: TensorBoardS_Hparam_Interval {
    get {
      if case .domainInterval(let v)? = _storage._domain {return v}
      return TensorBoardS_Hparam_Interval()
    }
    set {_uniqueStorage()._domain = .domainInterval(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies the set of values this hyperparameter can hold. The UI assumes
  /// every instance of this hyperparameter will hold a value from this set. It
  /// is used by the UI to allow filtering so that only session groups (see
  /// below) whose associated hyperparameter value "passes" the filter are
  /// displayed. If this is not populated, the domain is assumed to be the
  /// entire domain of the type of the hyperparameter.
  enum OneOf_Domain: Equatable {
    /// A discrete set of the values this hyperparameter can hold.
    case domainDiscrete(SwiftProtobuf.Google_Protobuf_ListValue)
    /// Numeric data type only. The (real) interval from which values of this
    /// hyperparameter are taken.
    case domainInterval(TensorBoardS_Hparam_Interval)

  #if !swift(>=4.1)
    static func ==(lhs: TensorBoardS_Hparam_HParamInfo.OneOf_Domain, rhs: TensorBoardS_Hparam_HParamInfo.OneOf_Domain) -> Bool {
      switch (lhs, rhs) {
      case (.domainDiscrete(let l), .domainDiscrete(let r)): return l == r
      case (.domainInterval(let l), .domainInterval(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents the closed interval [min_value, max_value] of the real line.
/// NEXT_TAG: 3
struct TensorBoardS_Hparam_Interval {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var minValue: Double = 0

  var maxValue: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// NEXT_TAG: 3
struct TensorBoardS_Hparam_MetricName {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An identifier for a metric. A metric is a real-valued function of the
  /// model. The UI can plot metrics for a session evaluated on the model at
  /// different training steps.
  ///
  /// We identify a metric by a (group, tag) pair of strings. The UI treats
  /// both of these as opaque strings. The only requirement is that the pair
  /// uniquely identifies a metric in the experiment.
  ///
  /// We use a pair so the UI could allow the user to group metrics for a
  /// single session by either group or tag to be displayed in the same chart.
  /// For instance, one can set the metric group to correspond to the dataset
  /// on which the model was evaluated, and the UI can then display different
  /// metrics describing the same underlying computation and using different
  /// datasets, on the same chart.
  ///
  /// When exporting summaries from Tensorflow, in a typical setup, a
  /// training session exports evaluations of metrics at different training steps
  /// as Scalar-plugin summaries--each having a run of the form
  /// "<session_base_log_dir>/<sub_dir>", and some associated tag. The same
  /// metric for different sessions would use the same sub_dir and tag, but
  /// would have a different session_base_log_dir. For example, a session
  /// computing two metrics: model loss on the validation set and model loss on
  /// the training set, can export these as scalar summaries with the tag "loss"
  /// and runs session_base_log_dir/validation and session_base_log_dir/training,
  /// respectively. In this setup, the 'group' field can be populated with
  /// the "sub_dir" associated with the metric, and the 'tag' field can be
  /// populated with the tag: "loss".
  var group: String = String()

  var tag: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// NEXT_TAG: 6
struct TensorBoardS_Hparam_MetricInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: TensorBoardS_Hparam_MetricName {
    get {return _storage._name ?? TensorBoardS_Hparam_MetricName()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  /// A string used to display the metric in the UI. If empty, the UI
  /// will display the 'name' field.
  var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  /// A description. May contain markdown.
  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// The dataset type (validation, training) on which the metric is computed.
  var datasetType: TensorBoardS_Hparam_DatasetType {
    get {return _storage._datasetType}
    set {_uniqueStorage()._datasetType = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// In some experiments, the user trains a model with the same set of
/// hyperparameters multiple times to get the distribution of metric
/// evaluations, when the computation (such as the training algorithm, or metric
/// evaluation) is non-deterministic. To make the UI aware of this, sessions
/// are partitioned into groups: each group consists of all training sessions
/// which share the same values for the hyperparameters. In experiments with no
/// repeated executions, each group consists of exactly one session.
/// NEXT_TAG: 6
struct TensorBoardS_Hparam_SessionGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  /// Stores the hyperparameters for sessions within this group as a mapping
  /// from the hyperparameter name to its value.
  var hparams: Dictionary<String,SwiftProtobuf.Google_Protobuf_Value> = [:]

  /// A list of pairs (metric, value)--one for each metric in the experiment.
  /// The value denotes the evaluation of the corresponding metric on
  /// the model aggregated across the sessions in this group. The exact method
  /// of aggregation is specified in the comments of ListSessionGroupsRequest.
  /// Unfortunately, we can't store these as a map, since proto maps can't have
  /// message keys.
  var metricValues: [TensorBoardS_Hparam_MetricValue] = []

  /// The sessions belonging to this group.
  var sessions: [TensorBoardS_Hparam_Session] = []

  /// An optional link to a web page monitoring the session group.
  var monitorURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// NEXT_TAG: 5
struct TensorBoardS_Hparam_MetricValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: TensorBoardS_Hparam_MetricName {
    get {return _storage._name ?? TensorBoardS_Hparam_MetricName()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  var value: Double {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  /// The training step at which this value is computed.
  var trainingStep: Int32 {
    get {return _storage._trainingStep}
    set {_uniqueStorage()._trainingStep = newValue}
  }

  /// The wall time in seconds since UNIX epoch at which this value is computed.
  var wallTimeSecs: Double {
    get {return _storage._wallTimeSecs}
    set {_uniqueStorage()._wallTimeSecs = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NEXT_TAG: 8
struct TensorBoardS_Hparam_Session {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An id for the session. Unique within an experiment (not just the group).
  var name: String = String()

  /// In seconds since the UNIX epoch.
  var startTimeSecs: Double = 0

  /// In seconds since the UNIX epoch.
  /// May be 0 if unavailable or the session has not finished yet.
  var endTimeSecs: Double = 0

  /// May be STATUS_UNKNOWN if unavailable.
  var status: TensorBoardS_Hparam_Status = .unknown

  /// A URI for a resource that will allow the user to reconstruct the model for
  /// this session. E.g., in Tensorflow this could point to a directory where the
  /// checkpoints are stored. Currently, this is treated opaquely by the UI
  /// and only displayed to the user as it is passed here.
  var modelUri: String = String()

  /// Stores each metric evaluation on the model at the current training step.
  /// Unfortunately, we can't store these as a map, since proto maps can't have
  /// message keys.
  var metricValues: [TensorBoardS_Hparam_MetricValue] = []

  /// An optional link to a web page monitoring the session.
  var monitorURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Parameters for a GetExperiment API call.
/// Each experiment is scoped by a unique global id.
/// NEXT_TAG: 2
struct TensorBoardS_Hparam_GetExperimentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// REQUIRED
  var experimentName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Parameters for a ListSessionGroups API call.
/// Computes a list of the current session groups allowing for filtering and
/// sorting by metrics and hyperparameter values. Returns a "slice" of
/// that list specified by start_index and slice_size.
/// NEXT_TAG: 8
struct TensorBoardS_Hparam_ListSessionGroupsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var experimentName: String {
    get {return _storage._experimentName}
    set {_uniqueStorage()._experimentName = newValue}
  }

  /// Filters the set of sessions (from which the session groups are formed) to
  /// contain only these sessions whose status is contained in
  /// 'allowed_statuses'.
  var allowedStatuses: [TensorBoardS_Hparam_Status] {
    get {return _storage._allowedStatuses}
    set {_uniqueStorage()._allowedStatuses = newValue}
  }

  /// A list of ColParams messages--one for each "column" of a session group. A
  /// session group column contains either a metric evaluated at the current
  /// reported computation step or a hyperparameter value. In addition to
  /// 'regular' values, a column may take on a special 'missing-value' which
  /// denotes that the hyperparameter or metric is not available
  /// for the session group (for example, if the metric is not used in the
  /// group).
  ///
  /// The ColParams messages in the repeated field below configure filtering and
  /// sorting of the resulting collection of session groups. See the comments of
  /// the fields in the ColParam message below for more details.
  var colParams: [TensorBoardS_Hparam_ColParams] {
    get {return _storage._colParams}
    set {_uniqueStorage()._colParams = newValue}
  }

  /// Fields controlling how to aggregate metrics across sessions within a
  /// session group.
  /// If aggregation_type is AGGREGATION_AVG, each metric value of the
  /// session group is the average of the values of the metric across the
  /// sessions.
  /// Otherwise, the session group metric values are taken directly from a
  /// "representative" session in the group, selected as a session for which
  /// primary_metric takes on its minimum, maximum, or median value, as
  /// specified by the choice of aggregation_type (for median, if the number of
  /// sessions in the group is even, a session with a lower "middle" value is
  /// chosen as the representative session).
  var aggregationType: TensorBoardS_Hparam_AggregationType {
    get {return _storage._aggregationType}
    set {_uniqueStorage()._aggregationType = newValue}
  }

  /// See comment for 'aggregation_type' above.
  var aggregationMetric: TensorBoardS_Hparam_MetricName {
    get {return _storage._aggregationMetric ?? TensorBoardS_Hparam_MetricName()}
    set {_uniqueStorage()._aggregationMetric = newValue}
  }
  /// Returns true if `aggregationMetric` has been explicitly set.
  var hasAggregationMetric: Bool {return _storage._aggregationMetric != nil}
  /// Clears the value of `aggregationMetric`. Subsequent reads from it will return its default value.
  mutating func clearAggregationMetric() {_uniqueStorage()._aggregationMetric = nil}

  /// The next two parameters determine the "slice" of the full list of
  /// session groups--sorted and filtered by the parameters above--to return.
  /// The 0-based index of the first session group to return.
  var startIndex: Int32 {
    get {return _storage._startIndex}
    set {_uniqueStorage()._startIndex = newValue}
  }

  /// The number of session groups to return starting at the session group
  /// indexed by 'start_index'. The actual number of session groups returned
  /// is min{slice_size, total_size - start_index}, where
  /// total_size is the number of session groups in the full list
  /// sorted and filtered by the parameters above (if start_index > total_size
  /// no session groups are returned).
  var sliceSize: Int32 {
    get {return _storage._sliceSize}
    set {_uniqueStorage()._sliceSize = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Defines parmeters for a ListSessionGroupsRequest for a specific column.
/// See the comment for "ListSessionGroupsRequest" above for more details.
/// NEXT_TAG: 9
struct TensorBoardS_Hparam_ColParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: OneOf_Name? {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var metric: TensorBoardS_Hparam_MetricName {
    get {
      if case .metric(let v)? = _storage._name {return v}
      return TensorBoardS_Hparam_MetricName()
    }
    set {_uniqueStorage()._name = .metric(newValue)}
  }

  var hparam: String {
    get {
      if case .hparam(let v)? = _storage._name {return v}
      return String()
    }
    set {_uniqueStorage()._name = .hparam(newValue)}
  }

  /// Sorting.
  /// The final order of session groups in the response is defined by the sub
  /// collection of ColParams messages (out of the
  /// ListSessionGroupsRequest.col_params repeated field) whose 'order' field
  /// (below) is not ORDER_UNSPECIFIED. In each of the messages in this
  /// sub-collection, the next two fields specify the ordering of the values
  /// and missing_values in the associated column of the session group. The
  /// order of the ColParams messages themselves within the sub-collection
  /// determines the "significance" of the associated column as a sorting key:
  /// with the first being the primary sorting key, the second being the
  /// secondary sorting key, etc.
  /// Note: The 'session group name' is added as a least significant sorting
  /// key to the keys defined by the user, so the order in the response is always
  /// deterministic.
  var order: TensorBoardS_Hparam_SortOrder {
    get {return _storage._order}
    set {_uniqueStorage()._order = newValue}
  }

  /// This field is ignored if order is ORDER_UNSPECIFIED.
  /// Otherwise, if true, missing values are ordered before every other value in
  /// the column; if false they are ordered after every other value in the
  /// column.
  var missingValuesFirst: Bool {
    get {return _storage._missingValuesFirst}
    set {_uniqueStorage()._missingValuesFirst = newValue}
  }

  /// Filtering.
  /// The 'filter' oneof specifies a subset of the domain of the values a column
  /// may take. Only session groups with each of their column values belonging
  /// to this subset are included in the response. If this field is not
  /// specified, the subset is taken to be the entire column domain.
  var filter: OneOf_Filter? {
    get {return _storage._filter}
    set {_uniqueStorage()._filter = newValue}
  }

  /// Only valid for string-valued hyperparameter columns. The subset is
  /// the set of all strings matching the regular expression stored
  /// in 'regexp' as a partial match (use '^<regexp>$' to have a full
  /// match against regexp).
  var filterRegexp: String {
    get {
      if case .filterRegexp(let v)? = _storage._filter {return v}
      return String()
    }
    set {_uniqueStorage()._filter = .filterRegexp(newValue)}
  }

  /// Only valid for numeric-valued columns. The subset is the given interval.
  var filterInterval: TensorBoardS_Hparam_Interval {
    get {
      if case .filterInterval(let v)? = _storage._filter {return v}
      return TensorBoardS_Hparam_Interval()
    }
    set {_uniqueStorage()._filter = .filterInterval(newValue)}
  }

  /// Valid for all data types. The subset is defined explicitly.
  var filterDiscrete: SwiftProtobuf.Google_Protobuf_ListValue {
    get {
      if case .filterDiscrete(let v)? = _storage._filter {return v}
      return SwiftProtobuf.Google_Protobuf_ListValue()
    }
    set {_uniqueStorage()._filter = .filterDiscrete(newValue)}
  }

  /// Specifies whether to exclude session groups whose column value is missing
  /// from the response.
  var excludeMissingValues: Bool {
    get {return _storage._excludeMissingValues}
    set {_uniqueStorage()._excludeMissingValues = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Name: Equatable {
    case metric(TensorBoardS_Hparam_MetricName)
    case hparam(String)

  #if !swift(>=4.1)
    static func ==(lhs: TensorBoardS_Hparam_ColParams.OneOf_Name, rhs: TensorBoardS_Hparam_ColParams.OneOf_Name) -> Bool {
      switch (lhs, rhs) {
      case (.metric(let l), .metric(let r)): return l == r
      case (.hparam(let l), .hparam(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Filtering.
  /// The 'filter' oneof specifies a subset of the domain of the values a column
  /// may take. Only session groups with each of their column values belonging
  /// to this subset are included in the response. If this field is not
  /// specified, the subset is taken to be the entire column domain.
  enum OneOf_Filter: Equatable {
    /// Only valid for string-valued hyperparameter columns. The subset is
    /// the set of all strings matching the regular expression stored
    /// in 'regexp' as a partial match (use '^<regexp>$' to have a full
    /// match against regexp).
    case filterRegexp(String)
    /// Only valid for numeric-valued columns. The subset is the given interval.
    case filterInterval(TensorBoardS_Hparam_Interval)
    /// Valid for all data types. The subset is defined explicitly.
    case filterDiscrete(SwiftProtobuf.Google_Protobuf_ListValue)

  #if !swift(>=4.1)
    static func ==(lhs: TensorBoardS_Hparam_ColParams.OneOf_Filter, rhs: TensorBoardS_Hparam_ColParams.OneOf_Filter) -> Bool {
      switch (lhs, rhs) {
      case (.filterRegexp(let l), .filterRegexp(let r)): return l == r
      case (.filterInterval(let l), .filterInterval(let r)): return l == r
      case (.filterDiscrete(let l), .filterDiscrete(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// See ListSessionGroups in http_api.md.
/// NEXT_TAG: 4
struct TensorBoardS_Hparam_ListSessionGroupsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionGroups: [TensorBoardS_Hparam_SessionGroup] = []

  /// Denotes the total number of session groups in the full filtered list.
  /// (Recall that this response may only be a slice).
  /// It is used by the UI to calculate total number of pages and can be
  /// set here to -1 to mean "unknown".
  var totalSize: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// See ListMetricEvalsRequest in http_api.md.
/// NEXT_TAG: 4
struct TensorBoardS_Hparam_ListMetricEvalsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var experimentName: String {
    get {return _storage._experimentName}
    set {_uniqueStorage()._experimentName = newValue}
  }

  var sessionName: String {
    get {return _storage._sessionName}
    set {_uniqueStorage()._sessionName = newValue}
  }

  var metricName: TensorBoardS_Hparam_MetricName {
    get {return _storage._metricName ?? TensorBoardS_Hparam_MetricName()}
    set {_uniqueStorage()._metricName = newValue}
  }
  /// Returns true if `metricName` has been explicitly set.
  var hasMetricName: Bool {return _storage._metricName != nil}
  /// Clears the value of `metricName`. Subsequent reads from it will return its default value.
  mutating func clearMetricName() {_uniqueStorage()._metricName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TensorBoardS.hparam"

extension TensorBoardS_Hparam_DataType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DATA_TYPE_UNSET"),
    1: .same(proto: "DATA_TYPE_STRING"),
    2: .same(proto: "DATA_TYPE_BOOL"),
    3: .same(proto: "DATA_TYPE_FLOAT64"),
  ]
}

extension TensorBoardS_Hparam_DatasetType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DATASET_UNKNOWN"),
    1: .same(proto: "DATASET_TRAINING"),
    2: .same(proto: "DATASET_VALIDATION"),
  ]
}

extension TensorBoardS_Hparam_Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_SUCCESS"),
    2: .same(proto: "STATUS_FAILURE"),
    3: .same(proto: "STATUS_RUNNING"),
  ]
}

extension TensorBoardS_Hparam_SortOrder: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORDER_UNSPECIFIED"),
    1: .same(proto: "ORDER_ASC"),
    2: .same(proto: "ORDER_DESC"),
  ]
}

extension TensorBoardS_Hparam_AggregationType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AGGREGATION_UNSET"),
    1: .same(proto: "AGGREGATION_AVG"),
    2: .same(proto: "AGGREGATION_MEDIAN"),
    3: .same(proto: "AGGREGATION_MIN"),
    4: .same(proto: "AGGREGATION_MAX"),
  ]
}

extension TensorBoardS_Hparam_Experiment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Experiment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "name"),
    1: .same(proto: "description"),
    2: .same(proto: "user"),
    3: .standard(proto: "time_created_secs"),
    4: .standard(proto: "hparam_infos"),
    5: .standard(proto: "metric_infos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.description_p)
      case 2: try decoder.decodeSingularStringField(value: &self.user)
      case 3: try decoder.decodeSingularDoubleField(value: &self.timeCreatedSecs)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.hparamInfos)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.metricInfos)
      case 6: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 1)
    }
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 2)
    }
    if self.timeCreatedSecs != 0 {
      try visitor.visitSingularDoubleField(value: self.timeCreatedSecs, fieldNumber: 3)
    }
    if !self.hparamInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hparamInfos, fieldNumber: 4)
    }
    if !self.metricInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metricInfos, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TensorBoardS_Hparam_Experiment, rhs: TensorBoardS_Hparam_Experiment) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.user != rhs.user {return false}
    if lhs.timeCreatedSecs != rhs.timeCreatedSecs {return false}
    if lhs.hparamInfos != rhs.hparamInfos {return false}
    if lhs.metricInfos != rhs.metricInfos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TensorBoardS_Hparam_HParamInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HParamInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "description"),
    4: .same(proto: "type"),
    5: .standard(proto: "domain_discrete"),
    6: .standard(proto: "domain_interval"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _displayName: String = String()
    var _description_p: String = String()
    var _type: TensorBoardS_Hparam_DataType = .unset
    var _domain: TensorBoardS_Hparam_HParamInfo.OneOf_Domain?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _displayName = source._displayName
      _description_p = source._description_p
      _type = source._type
      _domain = source._domain
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._displayName)
        case 3: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 5:
          var v: SwiftProtobuf.Google_Protobuf_ListValue?
          if let current = _storage._domain {
            try decoder.handleConflictingOneOf()
            if case .domainDiscrete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._domain = .domainDiscrete(v)}
        case 6:
          var v: TensorBoardS_Hparam_Interval?
          if let current = _storage._domain {
            try decoder.handleConflictingOneOf()
            if case .domainInterval(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._domain = .domainInterval(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 2)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 3)
      }
      if _storage._type != .unset {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 4)
      }
      switch _storage._domain {
      case .domainDiscrete(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .domainInterval(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TensorBoardS_Hparam_HParamInfo, rhs: TensorBoardS_Hparam_HParamInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._domain != rhs_storage._domain {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TensorBoardS_Hparam_Interval: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Interval"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_value"),
    2: .standard(proto: "max_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.minValue)
      case 2: try decoder.decodeSingularDoubleField(value: &self.maxValue)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minValue != 0 {
      try visitor.visitSingularDoubleField(value: self.minValue, fieldNumber: 1)
    }
    if self.maxValue != 0 {
      try visitor.visitSingularDoubleField(value: self.maxValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TensorBoardS_Hparam_Interval, rhs: TensorBoardS_Hparam_Interval) -> Bool {
    if lhs.minValue != rhs.minValue {return false}
    if lhs.maxValue != rhs.maxValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TensorBoardS_Hparam_MetricName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MetricName"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "tag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.group)
      case 2: try decoder.decodeSingularStringField(value: &self.tag)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.group.isEmpty {
      try visitor.visitSingularStringField(value: self.group, fieldNumber: 1)
    }
    if !self.tag.isEmpty {
      try visitor.visitSingularStringField(value: self.tag, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TensorBoardS_Hparam_MetricName, rhs: TensorBoardS_Hparam_MetricName) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TensorBoardS_Hparam_MetricInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MetricInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "display_name"),
    4: .same(proto: "description"),
    5: .standard(proto: "dataset_type"),
  ]

  fileprivate class _StorageClass {
    var _name: TensorBoardS_Hparam_MetricName? = nil
    var _displayName: String = String()
    var _description_p: String = String()
    var _datasetType: TensorBoardS_Hparam_DatasetType = .datasetUnknown

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _displayName = source._displayName
      _description_p = source._description_p
      _datasetType = source._datasetType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._name)
        case 3: try decoder.decodeSingularStringField(value: &_storage._displayName)
        case 4: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 5: try decoder.decodeSingularEnumField(value: &_storage._datasetType)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._name {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 3)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 4)
      }
      if _storage._datasetType != .datasetUnknown {
        try visitor.visitSingularEnumField(value: _storage._datasetType, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TensorBoardS_Hparam_MetricInfo, rhs: TensorBoardS_Hparam_MetricInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._datasetType != rhs_storage._datasetType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TensorBoardS_Hparam_SessionGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "hparams"),
    3: .standard(proto: "metric_values"),
    4: .same(proto: "sessions"),
    5: .standard(proto: "monitor_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Value>.self, value: &self.hparams)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.metricValues)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.sessions)
      case 5: try decoder.decodeSingularStringField(value: &self.monitorURL)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.hparams.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Value>.self, value: self.hparams, fieldNumber: 2)
    }
    if !self.metricValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metricValues, fieldNumber: 3)
    }
    if !self.sessions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sessions, fieldNumber: 4)
    }
    if !self.monitorURL.isEmpty {
      try visitor.visitSingularStringField(value: self.monitorURL, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TensorBoardS_Hparam_SessionGroup, rhs: TensorBoardS_Hparam_SessionGroup) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.hparams != rhs.hparams {return false}
    if lhs.metricValues != rhs.metricValues {return false}
    if lhs.sessions != rhs.sessions {return false}
    if lhs.monitorURL != rhs.monitorURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TensorBoardS_Hparam_MetricValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MetricValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
    3: .standard(proto: "training_step"),
    4: .standard(proto: "wall_time_secs"),
  ]

  fileprivate class _StorageClass {
    var _name: TensorBoardS_Hparam_MetricName? = nil
    var _value: Double = 0
    var _trainingStep: Int32 = 0
    var _wallTimeSecs: Double = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _value = source._value
      _trainingStep = source._trainingStep
      _wallTimeSecs = source._wallTimeSecs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._name)
        case 2: try decoder.decodeSingularDoubleField(value: &_storage._value)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._trainingStep)
        case 4: try decoder.decodeSingularDoubleField(value: &_storage._wallTimeSecs)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._name {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._value != 0 {
        try visitor.visitSingularDoubleField(value: _storage._value, fieldNumber: 2)
      }
      if _storage._trainingStep != 0 {
        try visitor.visitSingularInt32Field(value: _storage._trainingStep, fieldNumber: 3)
      }
      if _storage._wallTimeSecs != 0 {
        try visitor.visitSingularDoubleField(value: _storage._wallTimeSecs, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TensorBoardS_Hparam_MetricValue, rhs: TensorBoardS_Hparam_MetricValue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._trainingStep != rhs_storage._trainingStep {return false}
        if _storage._wallTimeSecs != rhs_storage._wallTimeSecs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TensorBoardS_Hparam_Session: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Session"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "start_time_secs"),
    3: .standard(proto: "end_time_secs"),
    4: .same(proto: "status"),
    5: .standard(proto: "model_uri"),
    6: .standard(proto: "metric_values"),
    7: .standard(proto: "monitor_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularDoubleField(value: &self.startTimeSecs)
      case 3: try decoder.decodeSingularDoubleField(value: &self.endTimeSecs)
      case 4: try decoder.decodeSingularEnumField(value: &self.status)
      case 5: try decoder.decodeSingularStringField(value: &self.modelUri)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.metricValues)
      case 7: try decoder.decodeSingularStringField(value: &self.monitorURL)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.startTimeSecs != 0 {
      try visitor.visitSingularDoubleField(value: self.startTimeSecs, fieldNumber: 2)
    }
    if self.endTimeSecs != 0 {
      try visitor.visitSingularDoubleField(value: self.endTimeSecs, fieldNumber: 3)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    if !self.modelUri.isEmpty {
      try visitor.visitSingularStringField(value: self.modelUri, fieldNumber: 5)
    }
    if !self.metricValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metricValues, fieldNumber: 6)
    }
    if !self.monitorURL.isEmpty {
      try visitor.visitSingularStringField(value: self.monitorURL, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TensorBoardS_Hparam_Session, rhs: TensorBoardS_Hparam_Session) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.startTimeSecs != rhs.startTimeSecs {return false}
    if lhs.endTimeSecs != rhs.endTimeSecs {return false}
    if lhs.status != rhs.status {return false}
    if lhs.modelUri != rhs.modelUri {return false}
    if lhs.metricValues != rhs.metricValues {return false}
    if lhs.monitorURL != rhs.monitorURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TensorBoardS_Hparam_GetExperimentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetExperimentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "experiment_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.experimentName)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.experimentName.isEmpty {
      try visitor.visitSingularStringField(value: self.experimentName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TensorBoardS_Hparam_GetExperimentRequest, rhs: TensorBoardS_Hparam_GetExperimentRequest) -> Bool {
    if lhs.experimentName != rhs.experimentName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TensorBoardS_Hparam_ListSessionGroupsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSessionGroupsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .standard(proto: "experiment_name"),
    7: .standard(proto: "allowed_statuses"),
    1: .standard(proto: "col_params"),
    2: .standard(proto: "aggregation_type"),
    3: .standard(proto: "aggregation_metric"),
    4: .standard(proto: "start_index"),
    5: .standard(proto: "slice_size"),
  ]

  fileprivate class _StorageClass {
    var _experimentName: String = String()
    var _allowedStatuses: [TensorBoardS_Hparam_Status] = []
    var _colParams: [TensorBoardS_Hparam_ColParams] = []
    var _aggregationType: TensorBoardS_Hparam_AggregationType = .aggregationUnset
    var _aggregationMetric: TensorBoardS_Hparam_MetricName? = nil
    var _startIndex: Int32 = 0
    var _sliceSize: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _experimentName = source._experimentName
      _allowedStatuses = source._allowedStatuses
      _colParams = source._colParams
      _aggregationType = source._aggregationType
      _aggregationMetric = source._aggregationMetric
      _startIndex = source._startIndex
      _sliceSize = source._sliceSize
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._colParams)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._aggregationType)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._aggregationMetric)
        case 4: try decoder.decodeSingularInt32Field(value: &_storage._startIndex)
        case 5: try decoder.decodeSingularInt32Field(value: &_storage._sliceSize)
        case 6: try decoder.decodeSingularStringField(value: &_storage._experimentName)
        case 7: try decoder.decodeRepeatedEnumField(value: &_storage._allowedStatuses)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._colParams.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._colParams, fieldNumber: 1)
      }
      if _storage._aggregationType != .aggregationUnset {
        try visitor.visitSingularEnumField(value: _storage._aggregationType, fieldNumber: 2)
      }
      if let v = _storage._aggregationMetric {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._startIndex != 0 {
        try visitor.visitSingularInt32Field(value: _storage._startIndex, fieldNumber: 4)
      }
      if _storage._sliceSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._sliceSize, fieldNumber: 5)
      }
      if !_storage._experimentName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._experimentName, fieldNumber: 6)
      }
      if !_storage._allowedStatuses.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._allowedStatuses, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TensorBoardS_Hparam_ListSessionGroupsRequest, rhs: TensorBoardS_Hparam_ListSessionGroupsRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._experimentName != rhs_storage._experimentName {return false}
        if _storage._allowedStatuses != rhs_storage._allowedStatuses {return false}
        if _storage._colParams != rhs_storage._colParams {return false}
        if _storage._aggregationType != rhs_storage._aggregationType {return false}
        if _storage._aggregationMetric != rhs_storage._aggregationMetric {return false}
        if _storage._startIndex != rhs_storage._startIndex {return false}
        if _storage._sliceSize != rhs_storage._sliceSize {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TensorBoardS_Hparam_ColParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ColParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metric"),
    2: .same(proto: "hparam"),
    3: .same(proto: "order"),
    4: .standard(proto: "missing_values_first"),
    5: .standard(proto: "filter_regexp"),
    6: .standard(proto: "filter_interval"),
    7: .standard(proto: "filter_discrete"),
    8: .standard(proto: "exclude_missing_values"),
  ]

  fileprivate class _StorageClass {
    var _name: TensorBoardS_Hparam_ColParams.OneOf_Name?
    var _order: TensorBoardS_Hparam_SortOrder = .orderUnspecified
    var _missingValuesFirst: Bool = false
    var _filter: TensorBoardS_Hparam_ColParams.OneOf_Filter?
    var _excludeMissingValues: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _order = source._order
      _missingValuesFirst = source._missingValuesFirst
      _filter = source._filter
      _excludeMissingValues = source._excludeMissingValues
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: TensorBoardS_Hparam_MetricName?
          if let current = _storage._name {
            try decoder.handleConflictingOneOf()
            if case .metric(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._name = .metric(v)}
        case 2:
          if _storage._name != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._name = .hparam(v)}
        case 3: try decoder.decodeSingularEnumField(value: &_storage._order)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._missingValuesFirst)
        case 5:
          if _storage._filter != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._filter = .filterRegexp(v)}
        case 6:
          var v: TensorBoardS_Hparam_Interval?
          if let current = _storage._filter {
            try decoder.handleConflictingOneOf()
            if case .filterInterval(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._filter = .filterInterval(v)}
        case 7:
          var v: SwiftProtobuf.Google_Protobuf_ListValue?
          if let current = _storage._filter {
            try decoder.handleConflictingOneOf()
            if case .filterDiscrete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._filter = .filterDiscrete(v)}
        case 8: try decoder.decodeSingularBoolField(value: &_storage._excludeMissingValues)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._name {
      case .metric(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .hparam(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      case nil: break
      }
      if _storage._order != .orderUnspecified {
        try visitor.visitSingularEnumField(value: _storage._order, fieldNumber: 3)
      }
      if _storage._missingValuesFirst != false {
        try visitor.visitSingularBoolField(value: _storage._missingValuesFirst, fieldNumber: 4)
      }
      switch _storage._filter {
      case .filterRegexp(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      case .filterInterval(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .filterDiscrete(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case nil: break
      }
      if _storage._excludeMissingValues != false {
        try visitor.visitSingularBoolField(value: _storage._excludeMissingValues, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TensorBoardS_Hparam_ColParams, rhs: TensorBoardS_Hparam_ColParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._order != rhs_storage._order {return false}
        if _storage._missingValuesFirst != rhs_storage._missingValuesFirst {return false}
        if _storage._filter != rhs_storage._filter {return false}
        if _storage._excludeMissingValues != rhs_storage._excludeMissingValues {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TensorBoardS_Hparam_ListSessionGroupsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSessionGroupsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_groups"),
    3: .standard(proto: "total_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.sessionGroups)
      case 3: try decoder.decodeSingularInt32Field(value: &self.totalSize)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionGroups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sessionGroups, fieldNumber: 1)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularInt32Field(value: self.totalSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TensorBoardS_Hparam_ListSessionGroupsResponse, rhs: TensorBoardS_Hparam_ListSessionGroupsResponse) -> Bool {
    if lhs.sessionGroups != rhs.sessionGroups {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TensorBoardS_Hparam_ListMetricEvalsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListMetricEvalsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "experiment_name"),
    1: .standard(proto: "session_name"),
    2: .standard(proto: "metric_name"),
  ]

  fileprivate class _StorageClass {
    var _experimentName: String = String()
    var _sessionName: String = String()
    var _metricName: TensorBoardS_Hparam_MetricName? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _experimentName = source._experimentName
      _sessionName = source._sessionName
      _metricName = source._metricName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._sessionName)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._metricName)
        case 3: try decoder.decodeSingularStringField(value: &_storage._experimentName)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._sessionName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionName, fieldNumber: 1)
      }
      if let v = _storage._metricName {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._experimentName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._experimentName, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TensorBoardS_Hparam_ListMetricEvalsRequest, rhs: TensorBoardS_Hparam_ListMetricEvalsRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._experimentName != rhs_storage._experimentName {return false}
        if _storage._sessionName != rhs_storage._sessionName {return false}
        if _storage._metricName != rhs_storage._metricName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
